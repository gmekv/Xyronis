{"version":3,"file":"472.bundle.js","mappings":"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","sources":["webpack://chairs-etc/./node_modules/@dimforge/rapier3d/coarena.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/control/character_controller.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/control/ray_cast_vehicle_controller.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/coefficient_combine_rule.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/island_manager.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/rigid_body.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/exports.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/broad_phase.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/collider.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/collider_set.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/contact.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/feature.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/narrow_phase.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/point.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/ray.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/shape.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/geometry/toi.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/math.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/event_queue.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/pipeline/world.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/rapier.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/rapier_wasm3d.js","webpack://chairs-etc/./node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js"],"sourcesContent":["export class Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map","import { RawKinematicCharacterController, RawCharacterCollision } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    setUp(vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    normalNudgeFactor() {\n        return this.raw.normalNudgeFactor();\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    setNormalNudgeFactor(value) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(c.translationDeltaApplied());\n            out.translationDeltaRemaining = VectorOps.fromRaw(c.translationDeltaRemaining());\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map","import { RawDynamicRayCastVehicleController } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A character controller to simulate vehicles using ray-casting for the wheels.\n */\nexport class DynamicRayCastVehicleController {\n    constructor(chassis, bodies, colliders, queries) {\n        this.raw = new RawDynamicRayCastVehicleController(chassis.handle);\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this._chassis = chassis;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the vehicles velocity based on its suspension, engine force, and brake.\n     *\n     * This directly updates the velocity of its chassis rigid-body.\n     *\n     * @param dt - Time increment used to integrate forces.\n     * @param filterFlags - Flag to exclude categories of objects from the wheels ray-cast.\n     * @param filterGroups - Only colliders compatible with these groups will be hit by the wheels ray-casts.\n     * @param filterPredicate - Callback to filter out which collider will be hit by the wheels ray-casts.\n     */\n    updateVehicle(dt, filterFlags, filterGroups, filterPredicate) {\n        this.raw.update_vehicle(dt, this.bodies.raw, this.colliders.raw, this.queries.raw, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * The current forward speed of the vehicle.\n     */\n    currentVehicleSpeed() {\n        return this.raw.current_vehicle_speed();\n    }\n    /**\n     * The rigid-body used as the chassis.\n     */\n    chassis() {\n        return this._chassis;\n    }\n    /**\n     * The chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexUpAxis() {\n        return this.raw.index_up_axis();\n    }\n    /**\n     * Sets the chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set indexUpAxis(axis) {\n        this.raw.set_index_up_axis(axis);\n    }\n    /**\n     * The chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexForwardAxis() {\n        return this.raw.index_forward_axis();\n    }\n    /**\n     * Sets the chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set setIndexForwardAxis(axis) {\n        this.raw.set_index_forward_axis(axis);\n    }\n    /**\n     * Adds a new wheel attached to this vehicle.\n     * @param chassisConnectionCs  - The position of the wheel relative to the chassis.\n     * @param directionCs - The direction of the wheels suspension, relative to the chassis. The ray-casting will\n     *                      happen following this direction to detect the ground.\n     * @param axleCs - The wheels axle axis, relative to the chassis.\n     * @param suspensionRestLength - The rest length of the wheels suspension spring.\n     * @param radius - The wheels radius.\n     */\n    addWheel(chassisConnectionCs, directionCs, axleCs, suspensionRestLength, radius) {\n        let rawChassisConnectionCs = VectorOps.intoRaw(chassisConnectionCs);\n        let rawDirectionCs = VectorOps.intoRaw(directionCs);\n        let rawAxleCs = VectorOps.intoRaw(axleCs);\n        this.raw.add_wheel(rawChassisConnectionCs, rawDirectionCs, rawAxleCs, suspensionRestLength, radius);\n        rawChassisConnectionCs.free();\n        rawDirectionCs.free();\n        rawAxleCs.free();\n    }\n    /**\n     * The number of wheels attached to this vehicle.\n     */\n    numWheels() {\n        return this.raw.num_wheels();\n    }\n    /*\n     *\n     * Access to wheel properties.\n     *\n     */\n    /*\n     * Getters + setters\n     */\n    /**\n     * The position of the i-th wheel, relative to the chassis.\n     */\n    wheelChassisConnectionPointCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_chassis_connection_point_cs(i));\n    }\n    /**\n     * Sets the position of the i-th wheel, relative to the chassis.\n     */\n    setWheelChassisConnectionPointCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_chassis_connection_point_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * The rest length of the i-th wheels suspension spring.\n     */\n    wheelSuspensionRestLength(i) {\n        return this.raw.wheel_suspension_rest_length(i);\n    }\n    /**\n     * Sets the rest length of the i-th wheels suspension spring.\n     */\n    setWheelSuspensionRestLength(i, value) {\n        this.raw.set_wheel_suspension_rest_length(i, value);\n    }\n    /**\n     * The maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    wheelMaxSuspensionTravel(i) {\n        return this.raw.wheel_max_suspension_travel(i);\n    }\n    /**\n     * Sets the maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    setWheelMaxSuspensionTravel(i, value) {\n        this.raw.set_wheel_max_suspension_travel(i, value);\n    }\n    /**\n     * The i-th wheels radius.\n     */\n    wheelRadius(i) {\n        return this.raw.wheel_radius(i);\n    }\n    /**\n     * Sets the i-th wheels radius.\n     */\n    setWheelRadius(i, value) {\n        this.raw.set_wheel_radius(i, value);\n    }\n    /**\n     * The i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    wheelSuspensionStiffness(i) {\n        return this.raw.wheel_suspension_stiffness(i);\n    }\n    /**\n     * Sets the i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    setWheelSuspensionStiffness(i, value) {\n        this.raw.set_wheel_suspension_stiffness(i, value);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    wheelSuspensionCompression(i) {\n        return this.raw.wheel_suspension_compression(i);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    setWheelSuspensionCompression(i, value) {\n        this.raw.set_wheel_suspension_compression(i, value);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    wheelSuspensionRelaxation(i) {\n        return this.raw.wheel_suspension_relaxation(i);\n    }\n    /**\n     * Sets the i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    setWheelSuspensionRelaxation(i, value) {\n        this.raw.set_wheel_suspension_relaxation(i, value);\n    }\n    /**\n     * The maximum force applied by the i-th wheels suspension.\n     */\n    wheelMaxSuspensionForce(i) {\n        return this.raw.wheel_max_suspension_force(i);\n    }\n    /**\n     * Sets the maximum force applied by the i-th wheels suspension.\n     */\n    setWheelMaxSuspensionForce(i, value) {\n        this.raw.set_wheel_max_suspension_force(i, value);\n    }\n    /**\n     * The maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    wheelBrake(i) {\n        return this.raw.wheel_brake(i);\n    }\n    /**\n     * Set the maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    setWheelBrake(i, value) {\n        this.raw.set_wheel_brake(i, value);\n    }\n    /**\n     * The steering angle (radians) for the i-th wheel.\n     */\n    wheelSteering(i) {\n        return this.raw.wheel_steering(i);\n    }\n    /**\n     * Sets the steering angle (radians) for the i-th wheel.\n     */\n    setWheelSteering(i, value) {\n        this.raw.set_wheel_steering(i, value);\n    }\n    /**\n     * The forward force applied by the i-th wheel on the chassis.\n     */\n    wheelEngineForce(i) {\n        return this.raw.wheel_engine_force(i);\n    }\n    /**\n     * Sets the forward force applied by the i-th wheel on the chassis.\n     */\n    setWheelEngineForce(i, value) {\n        this.raw.set_wheel_engine_force(i, value);\n    }\n    /**\n     * The direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    wheelDirectionCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_direction_cs(i));\n    }\n    /**\n     * Sets the direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    setWheelDirectionCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_direction_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * The i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    wheelAxleCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_axle_cs(i));\n    }\n    /**\n     * Sets the i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    setWheelAxleCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_axle_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * Parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    wheelFrictionSlip(i) {\n        return this.raw.wheel_friction_slip(i);\n    }\n    /**\n     * Sets the parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    setWheelFrictionSlip(i, value) {\n        this.raw.set_wheel_friction_slip(i, value);\n    }\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    wheelSideFrictionStiffness(i) {\n        return this.raw.wheel_side_friction_stiffness(i);\n    }\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    setWheelSideFrictionStiffness(i, value) {\n        this.raw.set_wheel_side_friction_stiffness(i, value);\n    }\n    /*\n     * Getters only.\n     */\n    /**\n     *  The i-th wheels current rotation angle (radians) on its axle.\n     */\n    wheelRotation(i) {\n        return this.raw.wheel_rotation(i);\n    }\n    /**\n     *  The forward impulses applied by the i-th wheel on the chassis.\n     */\n    wheelForwardImpulse(i) {\n        return this.raw.wheel_forward_impulse(i);\n    }\n    /**\n     *  The side impulses applied by the i-th wheel on the chassis.\n     */\n    wheelSideImpulse(i) {\n        return this.raw.wheel_side_impulse(i);\n    }\n    /**\n     *  The force applied by the i-th wheel suspension.\n     */\n    wheelSuspensionForce(i) {\n        return this.raw.wheel_suspension_force(i);\n    }\n    /**\n     *  The (world-space) contact normal between the i-th wheel and the floor.\n     */\n    wheelContactNormal(i) {\n        return VectorOps.fromRaw(this.raw.wheel_contact_normal_ws(i));\n    }\n    /**\n     *  The (world-space) point hit by the wheels ray-cast for the i-th wheel.\n     */\n    wheelContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.wheel_contact_point_ws(i));\n    }\n    /**\n     *  The suspension length for the i-th wheel.\n     */\n    wheelSuspensionLength(i) {\n        return this.raw.wheel_suspension_length(i);\n    }\n    /**\n     *  The (world-space) starting point of the ray-cast for the i-th wheel.\n     */\n    wheelHardPoint(i) {\n        return VectorOps.fromRaw(this.raw.wheel_hard_point_ws(i));\n    }\n    /**\n     *  Is the i-th wheel in contact with the ground?\n     */\n    wheelIsInContact(i) {\n        return this.raw.wheel_is_in_contact(i);\n    }\n    /**\n     *  The collider hit by the ray-cast for the i-th wheel.\n     */\n    wheelGroundObject(i) {\n        return this.colliders.get(this.raw.wheel_ground_object(i));\n    }\n}\n//# sourceMappingURL=ray_cast_vehicle_controller.js.map","import { RawCCDSolver } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport var CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawGenericJoint, RawJointAxis, RawJointType, } from \"../raw\";\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport var JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n    JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n    // #if DIM3\n    JointType[JointType[\"Spherical\"] = 5] = \"Spherical\";\n    JointType[JointType[\"Generic\"] = 6] = \"Generic\";\n    // #endif\n})(JointType || (JointType = {}));\nexport var MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.LinX || JointAxesMask.LinY\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport var JointAxesMask;\n(function (JointAxesMask) {\n    JointAxesMask[JointAxesMask[\"LinX\"] = 1] = \"LinX\";\n    JointAxesMask[JointAxesMask[\"LinY\"] = 2] = \"LinY\";\n    JointAxesMask[JointAxesMask[\"LinZ\"] = 4] = \"LinZ\";\n    JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n    JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n    JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nexport class ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Generic:\n                return new GenericImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    frameX1() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    frameX2() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n    // #endif\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nexport class FixedImpulseJoint extends ImpulseJoint {\n}\nexport class RopeImpulseJoint extends ImpulseJoint {\n}\nexport class SpringImpulseJoint extends ImpulseJoint {\n}\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.LinX;\n    }\n}\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class GenericImpulseJoint extends ImpulseJoint {\n}\nexport class SphericalImpulseJoint extends ImpulseJoint {\n}\n// #endif\nexport class JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n    static rope(length, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds generic joints.\n     *\n     * A generic joint allows customizing its degrees of freedom\n     * by supplying a mask of the joint axes that should remain locked.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - The X axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     * @param axesMask - Mask representing the locked axes of the joint. You can use logical OR to select these from\n     *                   the JointAxesMask enum. For example, passing (JointAxesMask.AngX || JointAxesMask.AngY) will\n     *                   create a joint locked in the X and Y rotational axes.\n     */\n    static generic(anchor1, anchor2, axis, axesMask) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.axesMask = axesMask;\n        res.jointType = JointType.Generic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static spherical(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static revolute(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM3\n                result = RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Generic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                // implicit type cast: axesMask is a JointAxesMask bitflag enum,\n                // we're treating it as a u8 on the Rust side\n                let rawAxesMask = this.axesMask;\n                result = RawGenericJoint.generic(rawA1, rawA2, rawAx, rawAxesMask);\n                break;\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map","import { RawImpulseJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { ImpulseJoint,\n// #endif\n } from \"./impulse_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map","import { RawIntegrationParameters } from \"../raw\";\nexport class IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get contact_erp() {\n        return this.raw.contact_erp;\n    }\n    get lengthUnit() {\n        return this.raw.lengthUnit;\n    }\n    /**\n     * Normalized amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError() {\n        return this.raw.normalizedAllowedLinearError;\n    }\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance() {\n        return this.raw.normalizedPredictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set contact_natural_frequency(value) {\n        this.raw.contact_natural_frequency = value;\n    }\n    set lengthUnit(value) {\n        this.raw.lengthUnit = value;\n    }\n    set normalizedAllowedLinearError(value) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n    set normalizedPredictionDistance(value) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value) {\n        this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value) {\n        this.raw.numInternalPgsIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n    switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n    switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map","import { RawIslandManager } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    constructor(raw) {\n        this.raw = raw || new RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map","import { RawJointAxis, RawJointType, } from \"../raw\";\nexport class MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitMultibodyJoint extends MultibodyJoint {\n}\nexport class FixedMultibodyJoint extends MultibodyJoint {\n}\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.LinX;\n    }\n}\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n}\n// #endif\n//# sourceMappingURL=multibody_joint.js.map","import { RawMultibodyJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { MultibodyJoint,\n// #endif\n } from \"./multibody_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map","import { RotationOps, VectorOps } from \"../math\";\n// #if DIM3\nimport { SdpMatrix3Ops } from \"../math\";\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport var RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledRotations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledRotations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    restrictRotations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    additionalSolverIterations() {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    setSoftCcdPrediction(distance) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    softCcdPrediction() {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(rot, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    setNextKinematicRotation(rot) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return VectorOps.fromRaw(this.rawSet.rbInvPrincipalInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    principalInertiaLocalFrame() {\n        return RotationOps.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame, wakeUp) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame, wakeUp);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userForce() {\n        return VectorOps.fromRaw(this.rawSet.rbUserForce(this.handle));\n    }\n    // #if DIM3\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userTorque() {\n        return VectorOps.fromRaw(this.rawSet.rbUserTorque(this.handle));\n    }\n}\nexport class RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    setLinvel(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y, z: z };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.enabledTranslations(false, false, false);\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    restrictRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        return this.enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        return this.restrictRotations(false, false, false);\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the objects path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    setSoftCcdPrediction(distance) {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map","import { RawRigidBodySet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { VectorOps, RotationOps } from \"../math\";\nimport { RigidBody, } from \"./rigid_body\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM3\n        rawAv, rawPrincipalInertia, rawInertiaFrame, desc.translationsEnabledX, desc.translationsEnabledY, desc.translationsEnabledZ, desc.rotationsEnabledX, desc.rotationsEnabledY, desc.rotationsEnabledZ, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.softCcdPrediction, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map","import { version as vers } from \"./raw\";\nexport function version() {\n    return vers();\n}\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n//# sourceMappingURL=exports.js.map","import { RawBroadPhase } from \"../raw\";\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map","import { RotationOps, VectorOps } from \"../math\";\nimport { CoefficientCombineRule, } from \"../dynamics\";\nimport { ActiveHooks, ActiveEvents } from \"../pipeline\";\nimport { Shape, Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, \n// #if DIM3\nCylinder, RoundCylinder, Cone, RoundCone, ConvexPolyhedron, RoundConvexPolyhedron,\n// #endif\n } from \"./shape\";\nimport { RayIntersection } from \"./ray\";\nimport { PointProjection } from \"./point\";\nimport { ColliderShapeCastHit, ShapeCastHit } from \"./toi\";\nimport { ShapeContact } from \"./contact\";\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport var ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    contactSkin() {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    setContactSkin(thickness) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotation(rot) {\n        this.colliderSet.raw.coSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotationWrtParent(rot) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNRows() {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNCols() {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n    // #endif\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n        let result = ColliderShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nexport var MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nexport class ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices, flags) {\n        const shape = new TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    static cuboid(hx, hy, hz) {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(nrows, ncols, heights, scale, flags) {\n        const shape = new Heightfield(nrows, ncols, heights, scale, flags);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    static cylinder(halfHeight, radius) {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    static cone(halfHeight, radius) {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexMesh(vertices, indices) {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const shape = new RoundConvexPolyhedron(vertices, indices, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    setContactSkin(thickness) {\n        this.contactSkin = thickness;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map","import { RawColliderSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { RotationOps, VectorOps } from \"../math\";\nimport { Collider } from \"./collider\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM3\n        rawPrincipalInertia, rawInertiaFrame, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, desc.contactSkin, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map","import { VectorOps } from \"../math\";\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), VectorOps.fromRaw(raw.point1()), VectorOps.fromRaw(raw.point2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map","// #if DIM3\nexport var FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Edge\"] = 1] = \"Edge\";\n    FeatureType[FeatureType[\"Face\"] = 2] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 3] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map","import { RawNarrowPhase } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nexport class TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    normal() {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM3\n    contactTangentImpulseX(i) {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n    contactTangentImpulseY(i) {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    constructor(timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.time_of_impact(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    constructor(collider, timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderHit {\n    constructor(collider, timeOfImpact) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderHit(colliderSet.get(raw.colliderHandle()), raw.timeOfImpact());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawShape, RawShapeType } from \"../raw\";\nimport { ShapeContact } from \"./contact\";\nimport { PointProjection } from \"./point\";\nimport { RayIntersection } from \"./ray\";\nimport { ShapeCastHit } from \"./toi\";\nexport class Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundCuboid(extents.x, extents.y, extents.z, borderRadius);\n            // #endif\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Segment(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]));\n            // #endif\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Triangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]));\n            // #endif\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundTriangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]), borderRadius);\n            // #endif\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                const hf_flags = rawSet.coHeightFieldFlags(handle);\n                return new Heightfield(nrows, ncols, heights, scale, hf_flags);\n            // #endif\n            // #if DIM3\n            case RawShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case RawShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case RawShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case RawShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case RawShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case RawShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, targetDistance, maxToi, stopAtPenetration) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeCastHit.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, targetDistance, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolyhedron\"] = 9] = \"ConvexPolyhedron\";\n    ShapeType[ShapeType[\"Cylinder\"] = 10] = \"Cylinder\";\n    ShapeType[ShapeType[\"Cone\"] = 11] = \"Cone\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 12] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 13] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundCylinder\"] = 14] = \"RoundCylinder\";\n    ShapeType[ShapeType[\"RoundCone\"] = 15] = \"RoundCone\";\n    ShapeType[ShapeType[\"RoundConvexPolyhedron\"] = 16] = \"RoundConvexPolyhedron\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 17] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// NOTE: this **must** match the bits in the HeightFieldFlags on the rust side.\n/**\n * Flags controlling the behavior of some operations involving heightfields.\n */\nexport var HeightFieldFlags;\n(function (HeightFieldFlags) {\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation (especially\n     * on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     */\n    HeightFieldFlags[HeightFieldFlags[\"FIX_INTERNAL_EDGES\"] = 1] = \"FIX_INTERNAL_EDGES\";\n})(HeightFieldFlags || (HeightFieldFlags = {}));\n// #endif\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nexport var TriMeshFlags;\n(function (TriMeshFlags) {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_BAD_TOPOLOGY_TRIANGLES\"] = 4] = \"DELETE_BAD_TOPOLOGY_TRIANGLES\";\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    TriMeshFlags[TriMeshFlags[\"ORIENTED\"] = 8] = \"ORIENTED\";\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    TriMeshFlags[TriMeshFlags[\"MERGE_DUPLICATE_VERTICES\"] = 16] = \"MERGE_DUPLICATE_VERTICES\";\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DEGENERATE_TRIANGLES\"] = 32] = \"DELETE_DEGENERATE_TRIANGLES\";\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DUPLICATE_TRIANGLES\"] = 64] = \"DELETE_DUPLICATE_TRIANGLES\";\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    TriMeshFlags[TriMeshFlags[\"FIX_INTERNAL_EDGES\"] = 152] = \"FIX_INTERNAL_EDGES\";\n})(TriMeshFlags || (TriMeshFlags = {}));\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.ball(this.radius);\n    }\n}\nexport class HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx, hy, hz) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, hz, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices, flags) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n    intoRaw() {\n        return RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.ConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        }\n        else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(vertices, indices, borderRadius) {\n        super();\n        this.type = ShapeType.RoundConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(this.vertices, this.indices, this.borderRadius);\n        }\n        else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(nrows, ncols, heights, scale, flags) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n        this.flags = flags;\n    }\n    intoRaw() {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.nrows, this.ncols, this.heights, rawScale, this.flags);\n        rawScale.free();\n        return rawShape;\n    }\n}\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cylinder;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCylinder;\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.roundCylinder(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        return RawShape.roundCone(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map","import { VectorOps } from \"../math\";\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeCastHit {\n    constructor(time_of_impact, witness1, witness2, normal1, normal2) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeCastHit(raw.time_of_impact(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class ColliderShapeCastHit extends ShapeCastHit {\n    constructor(collider, time_of_impact, witness1, witness2, normal1, normal2) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ColliderShapeCastHit(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map","import { RawVector, RawRotation } from \"./raw\";\n/**\n * A 3D vector.\n */\nexport class Vector3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\nexport class VectorOps {\n    static new(x, y, z) {\n        return new Vector3(x, y, z);\n    }\n    static intoRaw(v) {\n        return new RawVector(v.x, v.y, v.z);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n/**\n * A quaternion.\n */\nexport class Quaternion {\n    constructor(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\nexport class RotationOps {\n    static identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n    static intoRaw(rot) {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    get m11() {\n        return this.elements[0];\n    }\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    get m12() {\n        return this.elements[1];\n    }\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    get m21() {\n        return this.m12;\n    }\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    get m13() {\n        return this.elements[2];\n    }\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    get m31() {\n        return this.m13;\n    }\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    get m22() {\n        return this.elements[3];\n    }\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    get m23() {\n        return this.elements[4];\n    }\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    get m32() {\n        return this.m23;\n    }\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    get m33() {\n        return this.elements[5];\n    }\n}\nexport class SdpMatrix3Ops {\n    static fromRaw(raw) {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map","import { RawDebugRenderPipeline } from \"../raw\";\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map","import { RawEventQueue } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport var ActiveEvents;\n(function (ActiveEvents) {\n    ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map","export var ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nexport var SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map","import { RawPhysicsPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nexport class PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map","import { RawQueryPipeline } from \"../raw\";\nimport { PointColliderProjection, RayColliderIntersection, RayColliderHit, ColliderShapeCastHit, } from \"../geometry\";\nimport { RotationOps, VectorOps } from \"../math\";\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport var QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(colliders) {\n        this.raw.update(colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderHit.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = ColliderShapeCastHit.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map","import { RawSerializationPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nimport { World } from \"./world\";\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map","import { BroadPhase, ColliderSet, NarrowPhase, } from \"../geometry\";\nimport { CCDSolver, IntegrationParameters, IslandManager, ImpulseJointSet, MultibodyJointSet, RigidBodySet, } from \"../dynamics\";\nimport { VectorOps } from \"../math\";\nimport { PhysicsPipeline } from \"./physics_pipeline\";\nimport { QueryPipeline } from \"./query_pipeline\";\nimport { SerializationPipeline } from \"./serialization_pipeline\";\nimport { DebugRenderBuffers, DebugRenderPipeline } from \"./debug_render_pipeline\";\nimport { KinematicCharacterController } from \"../control\";\n// #if DIM3\nimport { DynamicRayCastVehicleController } from \"../control\";\n// #endif\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        // #if DIM3\n        this.vehicleControllers = new Set();\n        // #endif\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    // #endif\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        // #if DIM3\n        this.vehicleControllers.forEach((controller) => controller.free());\n        // #endif\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n        // #if DIM3\n        this.vehicleControllers = undefined;\n        // #endif\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit() {\n        return this.integrationParameters.lengthUnit;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    // #if DIM3\n    /**\n     * Creates a new vehicle controller.\n     *\n     * @param chassis - The rigid-body used as the chassis of the vehicle controller. When the vehicle\n     *                  controller is updated, it will change directly the rigid-bodys velocity. This\n     *                  rigid-body must be a dynamic or kinematic-velocity-based rigid-body.\n     */\n    createVehicleController(chassis) {\n        let controller = new DynamicRayCastVehicleController(chassis, this.bodies, this.colliders, this.queryPipeline);\n        this.vehicleControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a vehicle controller from this world.\n     *\n     * @param controller - The vehicle controller to remove.\n     */\n    removeVehicleController(controller) {\n        this.vehicleControllers.delete(controller);\n        controller.free();\n    }\n    // #endif\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance  If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map","import * as RAPIER from \"./exports\";\nexport * from \"./exports\";\nexport default RAPIER;\n//# sourceMappingURL=rapier.js.map","import * as wasm from \"./rapier_wasm3d_bg.wasm\";\nimport { __wbg_set_wasm } from \"./rapier_wasm3d_bg.js\";\n__wbg_set_wasm(wasm);\nexport * from \"./rapier_wasm3d_bg.js\";\n","let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ LinX:0,\"0\":\"LinX\",LinY:1,\"1\":\"LinY\",LinZ:2,\"2\":\"LinZ\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Rope:3,\"3\":\"Rope\",Spring:4,\"4\":\"Spring\",Spherical:5,\"5\":\"Spherical\",Generic:6,\"6\":\"Generic\", });\n\nconst RawBroadPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawbroadphase_free(ptr >>> 0));\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawBroadPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawBroadPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n\nconst RawCCDSolverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawccdsolver_free(ptr >>> 0));\n/**\n*/\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCCDSolverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n\nconst RawCharacterCollisionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcharactercollision_free(ptr >>> 0));\n/**\n*/\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCharacterCollisionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawColliderSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcolliderset_free(ptr >>> 0));\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coTriMeshFlags(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coTriMeshFlags(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightFieldFlags(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightFieldFlags(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} contact_skin\n    */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} target_distance\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {number} contactSkin\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawColliderShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcollidershapecasthit_free(ptr >>> 0));\n/**\n*/\nexport class RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactForceEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactforceevent_free(ptr >>> 0));\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactForceEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactForceEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawContactManifoldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactmanifold_free(ptr >>> 0));\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactManifoldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactManifoldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactpair_free(ptr >>> 0));\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n\nconst RawDebugRenderPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdebugrenderpipeline_free(ptr >>> 0));\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDebugRenderPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n\nconst RawDeserializedWorldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdeserializedworld_free(ptr >>> 0));\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n        RawDeserializedWorldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDeserializedWorldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n\nconst RawDynamicRayCastVehicleControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr >>> 0));\n/**\n*/\nexport class RawDynamicRayCastVehicleController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDynamicRayCastVehicleControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr);\n    }\n    /**\n    * @param {number} chassis\n    */\n    constructor(chassis) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_new(chassis);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    current_vehicle_speed() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    chassis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    index_up_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_up_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @returns {number}\n    */\n    index_forward_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_forward_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @param {RawVector} chassis_connection_cs\n    * @param {RawVector} direction_cs\n    * @param {RawVector} axle_cs\n    * @param {number} suspension_rest_length\n    * @param {number} radius\n    */\n    add_wheel(chassis_connection_cs, direction_cs, axle_cs, suspension_rest_length, radius) {\n        _assertClass(chassis_connection_cs, RawVector);\n        _assertClass(direction_cs, RawVector);\n        _assertClass(axle_cs, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, chassis_connection_cs.__wbg_ptr, direction_cs.__wbg_ptr, axle_cs.__wbg_ptr, suspension_rest_length, radius);\n    }\n    /**\n    * @returns {number}\n    */\n    num_wheels() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    update_vehicle(dt, bodies, colliders, queries, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            wasm.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_chassis_connection_point_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_chassis_connection_point_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_rest_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_rest_length(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_travel(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_travel(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_radius(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_radius(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_radius(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_stiffness(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_stiffness(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_compression(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_compression(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_relaxation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_relaxation(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_brake(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_brake(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_brake(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_steering(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_steering(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_steering(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_engine_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_engine_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_engine_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_direction_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_direction_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_axle_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_axle_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_friction_slip(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_friction_slip(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_friction_slip(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_side_friction_stiffness(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} stiffness\n    */\n    set_wheel_side_friction_stiffness(i, stiffness) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, i, stiffness);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_rotation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_rotation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_forward_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_side_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_side_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_normal_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_hard_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {boolean}\n    */\n    wheel_is_in_contact(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, i);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_ground_object(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_ground_object(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawEventQueueFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_raweventqueue_free(ptr >>> 0));\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawEventQueueFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n\nconst RawGenericJointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawgenericjoint_free(ptr >>> 0));\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n        RawGenericJointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawGenericJointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Creates a new joint descriptor that builds generic joints.\n    *\n    * Generic joints allow arbitrary axes of freedom to be selected\n    * for the joint from the available 6 degrees of freedom.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {number} lockedAxes\n    * @returns {RawGenericJoint | undefined}\n    */\n    static generic(anchor1, anchor2, axis, lockedAxes) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_generic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, lockedAxes);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds spherical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n\nconst RawImpulseJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawimpulsejointset_free(ptr >>> 0));\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawImpulseJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawImpulseJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawIntegrationParametersFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawintegrationparameters_free(ptr >>> 0));\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIntegrationParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIntegrationParametersFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get contact_erp() {\n        const ret = wasm.rawintegrationparameters_contact_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get lengthUnit() {\n        const ret = wasm.rawintegrationparameters_lengthUnit(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set contact_natural_frequency(value) {\n        wasm.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numInternalPgsIterations(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    /**\n    */\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n\nconst RawIslandManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawislandmanager_free(ptr >>> 0));\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIslandManagerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIslandManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawKinematicCharacterControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawkinematiccharactercontroller_free(ptr >>> 0));\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawKinematicCharacterControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawMultibodyJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawmultibodyjointset_free(ptr >>> 0));\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawMultibodyJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawMultibodyJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawNarrowPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawnarrowphase_free(ptr >>> 0));\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawNarrowPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawNarrowPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n\nconst RawPhysicsPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawphysicspipeline_free(ptr >>> 0));\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPhysicsPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n\nconst RawPointColliderProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointcolliderprojection_free(ptr >>> 0));\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointColliderProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointColliderProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawPointProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointprojection_free(ptr >>> 0));\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawQueryPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawquerypipeline_free(ptr >>> 0));\n/**\n*/\nexport class RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawQueryPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    update(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderHit | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawColliderShapeCastHit | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawRayColliderHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderhit_free(ptr >>> 0));\n/**\n*/\nexport class RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawRayColliderIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderintersection_free(ptr >>> 0));\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawRayIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrayintersection_free(ptr >>> 0));\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n\nconst RawRigidBodySetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrigidbodyset_free(ptr >>> 0));\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRigidBodySetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRigidBodySetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} prediction\n    */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The principal vectors of the local angular inertia tensor of the rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    * Retrieves the constant force(s) the user added to this rigid-body.\n    * Returns zero if the rigid-body is not dynamic.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbUserForce(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserForce(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Retrieves the constant torque(s) the user added to this rigid-body.\n    * Returns zero if the rigid-body is not dynamic.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbUserTorque(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {RawRigidBodyType} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {number} softCcdPrediction\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @param {number} additional_solver_iterations\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediction, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediction, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n\nconst RawRotationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrotation_free(ptr >>> 0));\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRotationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRotationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawSdpMatrix3Finalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawsdpmatrix3_free(ptr >>> 0));\n/**\n*/\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.__wbg_ptr = ptr;\n        RawSdpMatrix3Finalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSdpMatrix3Finalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr);\n    }\n    /**\n    * Row major list of the upper-triangular part of the symmetric matrix.\n    * @returns {Float32Array}\n    */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n\nconst RawSerializationPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawserializationpipeline_free(ptr >>> 0));\n/**\n*/\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSerializationPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n\nconst RawShapeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshape_free(ptr >>> 0));\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} flags\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @param {number} flags\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale, flags) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.__wbg_ptr, flags);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} target_distance\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeCastHit | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n\nconst RawShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecasthit_free(ptr >>> 0));\n/**\n*/\nexport class RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    time_of_impact() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawShapeContactFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecontact_free(ptr >>> 0));\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeContactFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeContactFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawVectorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawvector_free(ptr >>> 0));\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n        RawVectorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawVectorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawvector_set_z(this.__wbg_ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_b3ca7c6051f9bec1() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_8e7cb608789c2528() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_938992c832f74314() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_4d857b598695205e(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_12d079cc21e14bdb(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_63b92bc8671ed464(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_a47bac70306a19a7(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_c20a40f15020d68a(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_4a659d079a1650e0(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_bd975934d1b1fddb(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_d25bbcbc3367f684(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_1e8b839a06de01c5(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n"],"names":["Coarena","constructor","this","fconv","Float64Array","uconv","Uint32Array","buffer","data","Array","size","set","handle","i","index","length","push","len","clear","get","forEach","f","elt","getAll","filter","CharacterCollision","KinematicCharacterController","offset","params","bodies","colliders","queries","raw","rawCharacterCollision","_applyImpulsesToDynamicBodies","_characterMass","free","undefined","up","setUp","vector","rawVect","intoRaw","applyImpulsesToDynamicBodies","setApplyImpulsesToDynamicBodies","enabled","characterMass","setCharacterMass","mass","setOffset","value","normalNudgeFactor","setNormalNudgeFactor","slideEnabled","setSlideEnabled","autostepMaxHeight","autostepMinWidth","autostepIncludesDynamicBodies","autostepEnabled","enableAutostep","maxHeight","minWidth","includeDynamicBodies","disableAutostep","maxSlopeClimbAngle","setMaxSlopeClimbAngle","angle","minSlopeSlideAngle","setMinSlopeSlideAngle","snapToGroundDistance","enableSnapToGround","distance","disableSnapToGround","snapToGroundEnabled","computeColliderMovement","collider","desiredTranslationDelta","filterFlags","filterGroups","filterPredicate","rawTranslationDelta","dt","castClosure","computedMovement","fromRaw","computedGrounded","numComputedCollisions","computedCollision","out","c","translationDeltaApplied","translationDeltaRemaining","toi","witness1","worldWitness1","witness2","worldWitness2","normal1","worldNormal1","normal2","worldNormal2","DynamicRayCastVehicleController","chassis","_chassis","updateVehicle","update_vehicle","currentVehicleSpeed","current_vehicle_speed","indexUpAxis","index_up_axis","axis","set_index_up_axis","indexForwardAxis","index_forward_axis","setIndexForwardAxis","set_index_forward_axis","addWheel","chassisConnectionCs","directionCs","axleCs","suspensionRestLength","radius","rawChassisConnectionCs","rawDirectionCs","rawAxleCs","add_wheel","numWheels","num_wheels","wheelChassisConnectionPointCs","wheel_chassis_connection_point_cs","setWheelChassisConnectionPointCs","rawValue","set_wheel_chassis_connection_point_cs","wheelSuspensionRestLength","wheel_suspension_rest_length","setWheelSuspensionRestLength","set_wheel_suspension_rest_length","wheelMaxSuspensionTravel","wheel_max_suspension_travel","setWheelMaxSuspensionTravel","set_wheel_max_suspension_travel","wheelRadius","wheel_radius","setWheelRadius","set_wheel_radius","wheelSuspensionStiffness","wheel_suspension_stiffness","setWheelSuspensionStiffness","set_wheel_suspension_stiffness","wheelSuspensionCompression","wheel_suspension_compression","setWheelSuspensionCompression","set_wheel_suspension_compression","wheelSuspensionRelaxation","wheel_suspension_relaxation","setWheelSuspensionRelaxation","set_wheel_suspension_relaxation","wheelMaxSuspensionForce","wheel_max_suspension_force","setWheelMaxSuspensionForce","set_wheel_max_suspension_force","wheelBrake","wheel_brake","setWheelBrake","set_wheel_brake","wheelSteering","wheel_steering","setWheelSteering","set_wheel_steering","wheelEngineForce","wheel_engine_force","setWheelEngineForce","set_wheel_engine_force","wheelDirectionCs","wheel_direction_cs","setWheelDirectionCs","set_wheel_direction_cs","wheelAxleCs","wheel_axle_cs","setWheelAxleCs","set_wheel_axle_cs","wheelFrictionSlip","wheel_friction_slip","setWheelFrictionSlip","set_wheel_friction_slip","wheelSideFrictionStiffness","wheel_side_friction_stiffness","setWheelSideFrictionStiffness","set_wheel_side_friction_stiffness","wheelRotation","wheel_rotation","wheelForwardImpulse","wheel_forward_impulse","wheelSideImpulse","wheel_side_impulse","wheelSuspensionForce","wheel_suspension_force","wheelContactNormal","wheel_contact_normal_ws","wheelContactPoint","wheel_contact_point_ws","wheelSuspensionLength","wheel_suspension_length","wheelHardPoint","wheel_hard_point_ws","wheelIsInContact","wheel_is_in_contact","wheelGroundObject","wheel_ground_object","CCDSolver","CoefficientCombineRule","JointType","MotorModel","JointAxesMask","ImpulseJoint","rawSet","bodySet","newTyped","jointType","Revolute","RevoluteImpulseJoint","Prismatic","PrismaticImpulseJoint","Fixed","FixedImpulseJoint","Spring","SpringImpulseJoint","Rope","RopeImpulseJoint","Spherical","SphericalImpulseJoint","Generic","GenericImpulseJoint","finalizeDeserialization","isValid","contains","body1","jointBodyHandle1","body2","jointBodyHandle2","type","frameX1","jointFrameX1","frameX2","jointFrameX2","anchor1","jointAnchor1","anchor2","jointAnchor2","setAnchor1","newPos","rawPoint","jointSetAnchor1","setAnchor2","jointSetAnchor2","setContactsEnabled","jointSetContactsEnabled","contactsEnabled","jointContactsEnabled","UnitImpulseJoint","limitsEnabled","jointLimitsEnabled","rawAxis","limitsMin","jointLimitsMin","limitsMax","jointLimitsMax","setLimits","min","max","jointSetLimits","configureMotorModel","model","jointConfigureMotorModel","configureMotorVelocity","targetVel","factor","jointConfigureMotorVelocity","configureMotorPosition","targetPos","stiffness","damping","jointConfigureMotorPosition","configureMotor","jointConfigureMotor","LinX","AngX","JointData","fixed","frame1","frame2","res","spring","rest_length","rope","generic","axesMask","spherical","prismatic","revolute","rawAx","result","rawA1","rawA2","rawFra1","rawFra2","limits","rawAxesMask","ImpulseJointSet","map","forEachJointHandle","joint","createJoint","desc","parent1","parent2","wakeUp","rawParams","remove","unmap","forEachJointHandleAttachedToRigidBody","forEachJointAttachedToRigidBody","delete","IntegrationParameters","contact_erp","lengthUnit","normalizedAllowedLinearError","normalizedPredictionDistance","numSolverIterations","numAdditionalFrictionIterations","numInternalPgsIterations","minIslandSize","maxCcdSubsteps","contact_natural_frequency","switchToStandardPgsSolver","switchToSmallStepsPgsSolver","switchToSmallStepsPgsSolverWithoutWarmstart","IslandManager","forEachActiveRigidBodyHandle","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","SphericalMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","wake_up","RigidBodyType","RigidBody","colliderSet","lockTranslations","locked","rbLockTranslations","lockRotations","rbLockRotations","setEnabledTranslations","enableX","enableY","enableZ","rbSetEnabledTranslations","restrictTranslations","setEnabledRotations","rbSetEnabledRotations","restrictRotations","dominanceGroup","rbDominanceGroup","setDominanceGroup","group","rbSetDominanceGroup","additionalSolverIterations","rbAdditionalSolverIterations","setAdditionalSolverIterations","iters","rbSetAdditionalSolverIterations","enableCcd","rbEnableCcd","setSoftCcdPrediction","rbSetSoftCcdPrediction","softCcdPrediction","rbSoftCcdPrediction","translation","rbTranslation","rotation","rbRotation","nextTranslation","rbNextTranslation","nextRotation","rbNextRotation","setTranslation","tra","rbSetTranslation","x","y","z","setLinvel","vel","rawVel","rbSetLinvel","gravityScale","rbGravityScale","setGravityScale","rbSetGravityScale","setRotation","rot","rbSetRotation","w","setAngvel","rbSetAngvel","setNextKinematicTranslation","t","rbSetNextKinematicTranslation","setNextKinematicRotation","rbSetNextKinematicRotation","linvel","rbLinvel","angvel","rbAngvel","rbMass","effectiveInvMass","rbEffectiveInvMass","invMass","rbInvMass","localCom","rbLocalCom","worldCom","rbWorldCom","invPrincipalInertiaSqrt","rbInvPrincipalInertiaSqrt","principalInertia","rbPrincipalInertia","principalInertiaLocalFrame","rbPrincipalInertiaLocalFrame","effectiveWorldInvInertiaSqrt","rbEffectiveWorldInvInertiaSqrt","effectiveAngularInertia","rbEffectiveAngularInertia","sleep","rbSleep","rbWakeUp","isCcdEnabled","rbIsCcdEnabled","numColliders","rbNumColliders","rbCollider","setEnabled","rbSetEnabled","isEnabled","rbIsEnabled","bodyType","rbBodyType","setBodyType","rbSetBodyType","isSleeping","rbIsSleeping","isMoving","rbIsMoving","isFixed","rbIsFixed","isKinematic","rbIsKinematic","isDynamic","rbIsDynamic","linearDamping","rbLinearDamping","angularDamping","rbAngularDamping","setLinearDamping","rbSetLinearDamping","recomputeMassPropertiesFromColliders","rbRecomputeMassPropertiesFromColliders","setAdditionalMass","rbSetAdditionalMass","setAdditionalMassProperties","centerOfMass","principalAngularInertia","angularInertiaLocalFrame","rawCom","rawPrincipalInertia","rawInertiaFrame","rbSetAdditionalMassProperties","setAngularDamping","rbSetAngularDamping","resetForces","rbResetForces","resetTorques","rbResetTorques","addForce","force","rawForce","rbAddForce","applyImpulse","impulse","rawImpulse","rbApplyImpulse","addTorque","torque","rawTorque","rbAddTorque","applyTorqueImpulse","torqueImpulse","rawTorqueImpulse","rbApplyTorqueImpulse","addForceAtPoint","point","rbAddForceAtPoint","applyImpulseAtPoint","rbApplyImpulseAtPoint","userForce","rbUserForce","userTorque","rbUserTorque","RigidBodyDesc","status","zeros","identity","massOnly","translationsEnabledX","translationsEnabledY","translationsEnabledZ","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","canSleep","sleeping","ccdEnabled","dynamic","Dynamic","kinematicPositionBased","KinematicPositionBased","kinematicVelocityBased","KinematicVelocityBased","newDynamic","newKinematicPositionBased","newKinematicVelocityBased","newStatic","TypeError","copy","scale","enabledTranslations","enabledRotations","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","RigidBodySet","forEachRigidBodyHandle","rb","createRigidBody","rawTra","rawRot","rawLv","rawAv","body","islands","impulseJoints","multibodyJoints","forEachActiveRigidBody","version","BroadPhase","ActiveCollisionTypes","MassPropsMode","Collider","parent","shape","_parent","_shape","coParent","ensureShapeIsCached","coTranslation","coRotation","isSensor","coIsSensor","setSensor","coSetSensor","setShape","rawShape","coSetShape","coSetEnabled","coIsEnabled","setRestitution","restitution","coSetRestitution","setFriction","friction","coSetFriction","frictionCombineRule","coFrictionCombineRule","setFrictionCombineRule","rule","coSetFrictionCombineRule","restitutionCombineRule","coRestitutionCombineRule","setRestitutionCombineRule","coSetRestitutionCombineRule","setCollisionGroups","groups","coSetCollisionGroups","setSolverGroups","coSetSolverGroups","contactSkin","coContactSkin","setContactSkin","thickness","coSetContactSkin","activeHooks","coActiveHooks","setActiveHooks","coSetActiveHooks","activeEvents","coActiveEvents","setActiveEvents","coSetActiveEvents","activeCollisionTypes","coActiveCollisionTypes","setContactForceEventThreshold","threshold","coSetContactForceEventThreshold","contactForceEventThreshold","coContactForceEventThreshold","setActiveCollisionTypes","coSetActiveCollisionTypes","setDensity","density","coSetDensity","setMass","coSetMass","setMassProperties","coSetMassProperties","coSetTranslation","setTranslationWrtParent","coSetTranslationWrtParent","coSetRotation","setRotationWrtParent","coSetRotationWrtParent","shapeType","coShapeType","halfExtents","coHalfExtents","setHalfExtents","newHalfExtents","coSetHalfExtents","coRadius","setRadius","newRadius","coSetRadius","roundRadius","coRoundRadius","setRoundRadius","newBorderRadius","coSetRoundRadius","halfHeight","coHalfHeight","setHalfHeight","newHalfheight","coSetHalfHeight","vertices","coVertices","indices","coIndices","heightfieldHeights","coHeightfieldHeights","heightfieldScale","coHeightfieldScale","heightfieldNRows","coHeightfieldNRows","heightfieldNCols","coHeightfieldNCols","coFriction","coRestitution","coDensity","coMass","volume","coVolume","collisionGroups","coCollisionGroups","solverGroups","coSolverGroups","containsPoint","coContainsPoint","projectPoint","solid","coProjectPoint","intersectsRay","ray","maxToi","rawOrig","origin","rawDir","dir","coIntersectsRay","castShape","collider1Vel","shape2","shape2Pos","shape2Rot","shape2Vel","targetDistance","stopAtPenetration","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","rawShape2","coCastShape","castCollider","collider2","collider2Vel","rawCollider2Vel","coCastCollider","intersectsShape","shapePos2","shapeRot2","rawPos2","rawRot2","coIntersectsShape","contactShape","prediction","coContactShape","contactCollider","coContactCollider","castRay","coCastRay","castRayAndGetNormal","coCastRayAndGetNormal","ColliderDesc","massPropsMode","Density","Average","DEFAULT","NONE","ball","capsule","segment","a","b","triangle","roundTriangle","borderRadius","polyline","trimesh","flags","cuboid","hx","hy","hz","roundCuboid","heightfield","nrows","ncols","heights","cylinder","roundCylinder","cone","roundCone","convexHull","points","convexMesh","roundConvexHull","roundConvexMesh","sensor","Mass","MassProps","ColliderSet","forEachColliderHandle","createCollider","parentHandle","hasParent","isNaN","Error","ShapeContact","dist","point1","point2","FeatureType","NarrowPhase","tempManifold","TempContactManifold","contactPairsWith","collider1","contact_pairs_with","intersectionPairsWith","intersection_pairs_with","contactPair","rawPair","contact_pair","flipped","numContactManifolds","contactManifold","intersectionPair","intersection_pair","normal","localNormal1","local_n1","localNormal2","local_n2","subshape1","subshape2","numContacts","num_contacts","localContactPoint1","contact_local_p1","localContactPoint2","contact_local_p2","contactDist","contact_dist","contactFid1","contact_fid1","contactFid2","contact_fid2","contactImpulse","contact_impulse","contactTangentImpulseX","contact_tangent_impulse_x","contactTangentImpulseY","contact_tangent_impulse_y","numSolverContacts","num_solver_contacts","solverContactPoint","solver_contact_point","solverContactDist","solver_contact_dist","solverContactFriction","solver_contact_friction","solverContactRestitution","solver_contact_restitution","solverContactTangentVelocity","solver_contact_tangent_velocity","PointProjection","isInside","PointColliderProjection","featureType","featureId","Unknown","colliderHandle","Ray","pointAt","RayIntersection","timeOfImpact","time_of_impact","RayColliderIntersection","RayColliderHit","ShapeType","HeightFieldFlags","TriMeshFlags","Shape","rawType","extents","vs","Ball","Cuboid","RoundCuboid","Capsule","Segment","new","Polyline","Triangle","RoundTriangle","HalfSpace","coHalfspaceNormal","TriMesh","tri_flags","coTriMeshFlags","HeightField","hf_flags","coHeightFieldFlags","Heightfield","ConvexPolyhedron","RoundConvexPolyhedron","Cylinder","RoundCylinder","Cone","RoundCone","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawPos1","rawRot1","rawVel1","rawVel2","rawShape1","shapePos","shapeRot","rawPos","rawRayOrig","rawRayDir","super","n","halfspace","ra","rc","rawScale","ShapeCastHit","ColliderShapeCastHit","Vector3","VectorOps","v","input","Quaternion","RotationOps","SdpMatrix3","elements","m11","m12","m21","m13","m31","m22","m23","m32","m33","SdpMatrix3Ops","sdpMatrix3","DebugRenderBuffers","colors","DebugRenderPipeline","render","impulse_joints","multibody_joints","narrow_phase","ActiveEvents","TempContactForceEvent","totalForce","total_force","totalForceMagnitude","total_force_magnitude","maxForceDirection","max_force_direction","maxForceMagnitude","max_force_magnitude","EventQueue","autoDrain","drainCollisionEvents","drainContactForceEvents","event","ActiveHooks","SolverFlags","PhysicsPipeline","step","gravity","integrationParameters","broadPhase","narrowPhase","ccdSolver","eventQueue","hooks","rawG","stepWithEvents","filterContactPair","filterIntersectionPair","QueryFilterFlags","QueryPipeline","update","filterExcludeCollider","filterExcludeRigidBody","intersectionsWithRay","callback","rawInter","intersectionWithShape","projectPointAndGetFeature","intersectionsWithPoint","shapeVel","intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawCenter","rawHalfExtents","SerializationPipeline","serializeAll","rawGra","deserializeAll","World","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","queryPipeline","physicsPipeline","serializationPipeline","debugRenderPipeline","characterControllers","Set","vehicleControllers","controller","takeGravity","takeIntegrationParameters","takeIslandManager","takeBroadPhase","takeNarrowPhase","takeBodies","takeColliders","takeImpulseJoints","takeMultibodyJoints","takeSnapshot","restoreSnapshot","debugRender","propagateModifiedBodyPositionsToColliders","updateSceneQueries","timestep","unitsPerMeter","niter","createCharacterController","add","removeCharacterController","createVehicleController","removeVehicleController","createImpulseJoint","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","wasm","__wbg_set_wasm","val","heap","fill","heap_next","addHeapObject","obj","idx","getObject","takeObject","ret","dropObject","isLikeNone","cachedFloat64Memory0","getFloat64Memory0","byteLength","memory","cachedInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getStringFromWasm0","ptr","Uint8Array","subarray","deferred1_0","deferred1_1","retptr","__wbindgen_add_to_stack_pointer","r0","r1","__wbindgen_free","_assertClass","instance","klass","name","cachedFloat32Memory0","getFloat32Memory0","Float32Array","stack_pointer","addBorrowedObject","getArrayF32FromWasm0","cachedUint32Memory0","getUint32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","passArray32ToWasm0","handleError","args","apply","e","__wbindgen_exn_store","Object","freeze","Vertex","Edge","Face","RawShapeType","Compound","RawJointAxis","LinY","LinZ","AngY","AngZ","RawJointType","AccelerationBased","ForceBased","RawBroadPhaseFinalization","FinalizationRegistry","register","unregister","__wbg_rawbroadphase_free","RawBroadPhase","__wrap","create","prototype","__wbg_ptr","__destroy_into_raw","rawbroadphase_new","RawCCDSolverFinalization","__wbg_rawccdsolver_free","RawCCDSolver","rawccdsolver_new","RawCharacterCollisionFinalization","__wbg_rawcharactercollision_free","RawCharacterCollision","rawcharactercollision_new","rawcharactercollision_handle","rawcharactercollision_translationDeltaApplied","RawVector","rawcharactercollision_translationDeltaRemaining","rawcharactercollision_toi","rawcharactercollision_worldWitness1","rawcharactercollision_worldWitness2","rawcharactercollision_worldNormal1","rawcharactercollision_worldNormal2","RawColliderSetFinalization","__wbg_rawcolliderset_free","RawColliderSet","rawcolliderset_coTranslation","rawcolliderset_coRotation","RawRotation","rawcolliderset_coSetTranslation","rawcolliderset_coSetTranslationWrtParent","rawcolliderset_coSetRotation","rawcolliderset_coSetRotationWrtParent","rawcolliderset_coIsSensor","rawcolliderset_coShapeType","rawcolliderset_coHalfspaceNormal","rawcolliderset_coHalfExtents","rawcolliderset_coSetHalfExtents","rawcolliderset_coRadius","rawcolliderset_coSetRadius","rawcolliderset_coHalfHeight","rawcolliderset_coSetHalfHeight","rawcolliderset_coRoundRadius","rawcolliderset_coSetRoundRadius","rawcolliderset_coVertices","v1","slice","rawcolliderset_coIndices","rawcolliderset_coTriMeshFlags","rawcolliderset_coHeightFieldFlags","rawcolliderset_coHeightfieldHeights","rawcolliderset_coHeightfieldScale","rawcolliderset_coHeightfieldNRows","rawcolliderset_coHeightfieldNCols","rawcolliderset_coParent","r2","rawcolliderset_coSetEnabled","rawcolliderset_coIsEnabled","contact_skin","rawcolliderset_coSetContactSkin","rawcolliderset_coContactSkin","rawcolliderset_coFriction","rawcolliderset_coRestitution","rawcolliderset_coDensity","rawcolliderset_coMass","rawcolliderset_coVolume","rawcolliderset_coCollisionGroups","rawcolliderset_coSolverGroups","rawcolliderset_coActiveHooks","rawcolliderset_coActiveCollisionTypes","rawcolliderset_coActiveEvents","rawcolliderset_coContactForceEventThreshold","rawcolliderset_coContainsPoint","colliderVel","target_distance","stop_at_penetration","RawShape","rawcolliderset_coCastShape","RawShapeCastHit","collider2handle","max_toi","rawcolliderset_coCastCollider","RawColliderShapeCastHit","rawcolliderset_coIntersectsShape","rawcolliderset_coContactShape","RawShapeContact","rawcolliderset_coContactCollider","rawcolliderset_coProjectPoint","RawPointProjection","rayOrig","rayDir","rawcolliderset_coIntersectsRay","rawcolliderset_coCastRay","rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","is_sensor","rawcolliderset_coSetSensor","rawcolliderset_coSetRestitution","rawcolliderset_coSetFriction","rawcolliderset_coFrictionCombineRule","rawcolliderset_coSetFrictionCombineRule","rawcolliderset_coRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","rawcolliderset_coSetCollisionGroups","rawcolliderset_coSetSolverGroups","rawcolliderset_coSetActiveHooks","events","rawcolliderset_coSetActiveEvents","types","rawcolliderset_coSetActiveCollisionTypes","rawcolliderset_coSetShape","rawcolliderset_coSetContactForceEventThreshold","rawcolliderset_coSetDensity","rawcolliderset_coSetMass","angularInertiaFrame","rawcolliderset_coSetMassProperties","rawcolliderset_new","rawcolliderset_len","rawcolliderset_contains","RawRigidBodySet","rawcolliderset_createCollider","RawIslandManager","rawcolliderset_remove","isHandleValid","rawcolliderset_forEachColliderHandle","RawColliderShapeCastHitFinalization","__wbg_rawcollidershapecasthit_free","rawcollidershapecasthit_time_of_impact","rawcollidershapecasthit_witness1","rawcollidershapecasthit_witness2","RawContactForceEventFinalization","__wbg_rawcontactforceevent_free","RawContactForceEvent","rawcontactforceevent_collider2","rawcontactforceevent_total_force","rawcontactforceevent_total_force_magnitude","rawcontactforceevent_max_force_direction","rawcontactforceevent_max_force_magnitude","RawContactManifoldFinalization","__wbg_rawcontactmanifold_free","RawContactManifold","rawcontactmanifold_normal","rawcontactmanifold_local_n1","rawcontactmanifold_local_n2","rawcontactmanifold_subshape1","rawcontactmanifold_subshape2","rawcontactmanifold_num_contacts","rawcontactmanifold_contact_local_p1","rawcontactmanifold_contact_local_p2","rawcontactmanifold_contact_dist","rawcontactmanifold_contact_fid1","rawcontactmanifold_contact_fid2","rawcontactmanifold_contact_impulse","rawcontactmanifold_contact_tangent_impulse_x","rawcontactmanifold_contact_tangent_impulse_y","rawcontactmanifold_num_solver_contacts","rawcontactmanifold_solver_contact_point","rawcontactmanifold_solver_contact_dist","rawcontactmanifold_solver_contact_friction","rawcontactmanifold_solver_contact_restitution","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPairFinalization","__wbg_rawcontactpair_free","RawContactPair","rawcontactpair_collider1","rawcontactpair_collider2","rawcontactpair_numContactManifolds","rawcontactpair_contactManifold","RawDebugRenderPipelineFinalization","__wbg_rawdebugrenderpipeline_free","RawDebugRenderPipeline","rawdebugrenderpipeline_new","rawdebugrenderpipeline_vertices","rawdebugrenderpipeline_colors","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","rawdebugrenderpipeline_render","RawDeserializedWorldFinalization","__wbg_rawdeserializedworld_free","RawDeserializedWorld","rawdeserializedworld_takeGravity","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","rawdeserializedworld_takeIslandManager","rawdeserializedworld_takeBroadPhase","rawdeserializedworld_takeNarrowPhase","rawdeserializedworld_takeBodies","rawdeserializedworld_takeColliders","rawdeserializedworld_takeImpulseJoints","rawdeserializedworld_takeMultibodyJoints","RawDynamicRayCastVehicleControllerFinalization","__wbg_rawdynamicraycastvehiclecontroller_free","RawDynamicRayCastVehicleController","rawdynamicraycastvehiclecontroller_new","rawdynamicraycastvehiclecontroller_current_vehicle_speed","rawdynamicraycastvehiclecontroller_chassis","rawdynamicraycastvehiclecontroller_index_up_axis","rawdynamicraycastvehiclecontroller_set_index_up_axis","rawdynamicraycastvehiclecontroller_index_forward_axis","rawdynamicraycastvehiclecontroller_set_index_forward_axis","chassis_connection_cs","direction_cs","axle_cs","suspension_rest_length","rawdynamicraycastvehiclecontroller_add_wheel","rawdynamicraycastvehiclecontroller_num_wheels","filter_flags","filter_groups","filter_predicate","RawQueryPipeline","rawdynamicraycastvehiclecontroller_update_vehicle","rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs","rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs","rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length","rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length","rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel","rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel","rawdynamicraycastvehiclecontroller_wheel_radius","rawdynamicraycastvehiclecontroller_set_wheel_radius","rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness","rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness","rawdynamicraycastvehiclecontroller_wheel_suspension_compression","rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression","rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation","rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation","rawdynamicraycastvehiclecontroller_wheel_max_suspension_force","rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force","rawdynamicraycastvehiclecontroller_wheel_brake","rawdynamicraycastvehiclecontroller_set_wheel_brake","rawdynamicraycastvehiclecontroller_wheel_steering","rawdynamicraycastvehiclecontroller_set_wheel_steering","rawdynamicraycastvehiclecontroller_wheel_engine_force","rawdynamicraycastvehiclecontroller_set_wheel_engine_force","rawdynamicraycastvehiclecontroller_wheel_direction_cs","rawdynamicraycastvehiclecontroller_set_wheel_direction_cs","rawdynamicraycastvehiclecontroller_wheel_axle_cs","rawdynamicraycastvehiclecontroller_set_wheel_axle_cs","rawdynamicraycastvehiclecontroller_wheel_friction_slip","rawdynamicraycastvehiclecontroller_set_wheel_friction_slip","rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness","rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness","rawdynamicraycastvehiclecontroller_wheel_rotation","rawdynamicraycastvehiclecontroller_wheel_forward_impulse","rawdynamicraycastvehiclecontroller_wheel_side_impulse","rawdynamicraycastvehiclecontroller_wheel_suspension_force","rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws","rawdynamicraycastvehiclecontroller_wheel_contact_point_ws","rawdynamicraycastvehiclecontroller_wheel_suspension_length","rawdynamicraycastvehiclecontroller_wheel_hard_point_ws","rawdynamicraycastvehiclecontroller_wheel_is_in_contact","rawdynamicraycastvehiclecontroller_wheel_ground_object","RawEventQueueFinalization","__wbg_raweventqueue_free","RawEventQueue","raweventqueue_new","raweventqueue_drainCollisionEvents","raweventqueue_drainContactForceEvents","raweventqueue_clear","RawGenericJointFinalization","__wbg_rawgenericjoint_free","RawGenericJoint","lockedAxes","rawgenericjoint_generic","rawgenericjoint_spring","rawgenericjoint_rope","rawgenericjoint_spherical","rawgenericjoint_prismatic","axes1","axes2","rawgenericjoint_fixed","rawgenericjoint_revolute","RawImpulseJointSetFinalization","__wbg_rawimpulsejointset_free","rawimpulsejointset_jointType","rawimpulsejointset_jointBodyHandle1","rawimpulsejointset_jointBodyHandle2","rawimpulsejointset_jointFrameX1","rawimpulsejointset_jointFrameX2","rawimpulsejointset_jointAnchor1","rawimpulsejointset_jointAnchor2","rawimpulsejointset_jointSetAnchor1","rawimpulsejointset_jointSetAnchor2","rawimpulsejointset_jointContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","rawimpulsejointset_jointLimitsEnabled","rawimpulsejointset_jointLimitsMin","rawimpulsejointset_jointLimitsMax","rawimpulsejointset_jointSetLimits","rawimpulsejointset_jointConfigureMotorModel","rawimpulsejointset_jointConfigureMotorVelocity","rawimpulsejointset_jointConfigureMotorPosition","rawimpulsejointset_jointConfigureMotor","rawimpulsejointset_new","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","rawimpulsejointset_forEachJointHandle","rawimpulsejointset_forEachJointAttachedToRigidBody","RawIntegrationParametersFinalization","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","rawintegrationparameters_dt","rawintegrationparameters_contact_erp","rawintegrationparameters_numSolverIterations","rawintegrationparameters_maxCcdSubsteps","rawintegrationparameters_lengthUnit","rawintegrationparameters_set_dt","rawintegrationparameters_set_contact_natural_frequency","rawintegrationparameters_set_normalizedAllowedLinearError","rawintegrationparameters_set_normalizedPredictionDistance","rawintegrationparameters_set_numSolverIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","rawintegrationparameters_set_lengthUnit","rawintegrationparameters_switchToStandardPgsSolver","rawintegrationparameters_switchToSmallStepsPgsSolver","rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart","RawIslandManagerFinalization","__wbg_rawislandmanager_free","rawislandmanager_new","rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterControllerFinalization","__wbg_rawkinematiccharactercontroller_free","RawKinematicCharacterController","rawkinematiccharactercontroller_new","rawkinematiccharactercontroller_setUp","rawkinematiccharactercontroller_normalNudgeFactor","rawkinematiccharactercontroller_setNormalNudgeFactor","rawkinematiccharactercontroller_setOffset","rawkinematiccharactercontroller_slideEnabled","rawkinematiccharactercontroller_setSlideEnabled","rawkinematiccharactercontroller_autostepMaxHeight","rawkinematiccharactercontroller_autostepMinWidth","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepEnabled","rawkinematiccharactercontroller_enableAutostep","rawkinematiccharactercontroller_disableAutostep","rawkinematiccharactercontroller_maxSlopeClimbAngle","rawkinematiccharactercontroller_setMaxSlopeClimbAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","rawkinematiccharactercontroller_snapToGroundDistance","rawkinematiccharactercontroller_enableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","rawkinematiccharactercontroller_snapToGroundEnabled","collider_handle","desired_translation_delta","apply_impulses_to_dynamic_bodies","character_mass","rawkinematiccharactercontroller_computeColliderMovement","rawkinematiccharactercontroller_computedMovement","rawkinematiccharactercontroller_computedGrounded","rawkinematiccharactercontroller_numComputedCollisions","collision","rawkinematiccharactercontroller_computedCollision","RawMultibodyJointSetFinalization","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","RawNarrowPhaseFinalization","__wbg_rawnarrowphase_free","rawnarrowphase_new","handle1","rawnarrowphase_contact_pairs_with","handle2","rawnarrowphase_contact_pair","rawnarrowphase_intersection_pairs_with","rawnarrowphase_intersection_pair","RawPhysicsPipelineFinalization","__wbg_rawphysicspipeline_free","RawPhysicsPipeline","rawphysicspipeline_new","joints","articulations","ccd_solver","rawphysicspipeline_step","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPointColliderProjectionFinalization","__wbg_rawpointcolliderprojection_free","RawPointColliderProjection","rawpointcolliderprojection_colliderHandle","rawpointcolliderprojection_point","rawpointcolliderprojection_isInside","rawpointcolliderprojection_featureType","rawpointcolliderprojection_featureId","RawPointProjectionFinalization","__wbg_rawpointprojection_free","rawpointprojection_point","rawpointprojection_isInside","RawQueryPipelineFinalization","__wbg_rawquerypipeline_free","rawquerypipeline_new","rawquerypipeline_update","filter_exclude_collider","filter_exclude_rigid_body","rawquerypipeline_castRay","RawRayColliderHit","rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","rawquerypipeline_intersectionsWithRay","rawquerypipeline_intersectionWithShape","rawquerypipeline_projectPoint","rawquerypipeline_projectPointAndGetFeature","rawquerypipeline_intersectionsWithPoint","rawquerypipeline_castShape","rawquerypipeline_intersectionsWithShape","rawquerypipeline_collidersWithAabbIntersectingAabb","RawRayColliderHitFinalization","__wbg_rawraycolliderhit_free","RawRayColliderIntersectionFinalization","__wbg_rawraycolliderintersection_free","RawRayIntersectionFinalization","__wbg_rawrayintersection_free","RawRigidBodySetFinalization","__wbg_rawrigidbodyset_free","rawrigidbodyset_rbTranslation","rawrigidbodyset_rbRotation","rawrigidbodyset_rbSleep","rawrigidbodyset_rbIsSleeping","rawrigidbodyset_rbIsMoving","rawrigidbodyset_rbNextTranslation","rawrigidbodyset_rbNextRotation","rawrigidbodyset_rbSetTranslation","rawrigidbodyset_rbSetRotation","rawrigidbodyset_rbSetLinvel","rawrigidbodyset_rbSetAngvel","rawrigidbodyset_rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicRotation","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMassProperties","rawrigidbodyset_rbLinvel","rawrigidbodyset_rbAngvel","rawrigidbodyset_rbLockTranslations","allow_x","allow_y","allow_z","rawrigidbodyset_rbSetEnabledTranslations","rawrigidbodyset_rbLockRotations","rawrigidbodyset_rbSetEnabledRotations","rawrigidbodyset_rbDominanceGroup","rawrigidbodyset_rbSetDominanceGroup","rawrigidbodyset_rbEnableCcd","rawrigidbodyset_rbSetSoftCcdPrediction","rawrigidbodyset_rbMass","rawrigidbodyset_rbInvMass","rawrigidbodyset_rbEffectiveInvMass","rawrigidbodyset_rbLocalCom","rawrigidbodyset_rbWorldCom","rawrigidbodyset_rbInvPrincipalInertiaSqrt","rawrigidbodyset_rbPrincipalInertiaLocalFrame","rawrigidbodyset_rbPrincipalInertia","rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","RawSdpMatrix3","rawrigidbodyset_rbEffectiveAngularInertia","rawrigidbodyset_rbWakeUp","rawrigidbodyset_rbIsCcdEnabled","rawrigidbodyset_rbSoftCcdPrediction","rawrigidbodyset_rbNumColliders","at","rawrigidbodyset_rbCollider","rawrigidbodyset_rbBodyType","rawrigidbodyset_rbSetBodyType","rawrigidbodyset_rbIsFixed","rawrigidbodyset_rbIsKinematic","rawrigidbodyset_rbIsDynamic","rawrigidbodyset_rbLinearDamping","rawrigidbodyset_rbAngularDamping","rawrigidbodyset_rbSetLinearDamping","rawrigidbodyset_rbSetAngularDamping","rawrigidbodyset_rbSetEnabled","rawrigidbodyset_rbIsEnabled","rawrigidbodyset_rbGravityScale","rawrigidbodyset_rbSetGravityScale","rawrigidbodyset_rbResetForces","rawrigidbodyset_rbResetTorques","rawrigidbodyset_rbAddForce","rawrigidbodyset_rbApplyImpulse","rawrigidbodyset_rbAddTorque","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rawrigidbodyset_rbAddForceAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rawrigidbodyset_rbAdditionalSolverIterations","rawrigidbodyset_rbSetAdditionalSolverIterations","rbUserData","rawrigidbodyset_rbUserData","rbSetUserData","rawrigidbodyset_rbSetUserData","rawrigidbodyset_rbUserForce","rawrigidbodyset_rbUserTorque","rawrigidbodyset_new","translationEnabledX","translationEnabledY","translationEnabledZ","rotationEnabledX","rotationEnabledY","rotationEnabledZ","rb_type","additional_solver_iterations","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_contains","rawrigidbodyset_forEachRigidBodyHandle","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","RawRotationFinalization","__wbg_rawrotation_free","rawrotation_new","rawrotation_identity","rawrotation_x","rawrotation_w","RawSdpMatrix3Finalization","__wbg_rawsdpmatrix3_free","rawsdpmatrix3_elements","RawSerializationPipelineFinalization","__wbg_rawserializationpipeline_free","RawSerializationPipeline","rawserializationpipeline_new","rawserializationpipeline_serializeAll","rawserializationpipeline_deserializeAll","RawShapeFinalization","__wbg_rawshape_free","rawshape_cuboid","rawshape_roundCuboid","rawshape_ball","rawshape_halfspace","rawshape_capsule","rawshape_cylinder","rawshape_roundCylinder","rawshape_cone","rawshape_roundCone","ptr0","__wbindgen_malloc","len0","ptr1","len1","rawshape_polyline","rawshape_trimesh","rawshape_heightfield","p1","p2","rawshape_segment","p3","rawshape_triangle","rawshape_roundTriangle","rawshape_convexHull","rawshape_roundConvexHull","rawshape_convexMesh","rawshape_roundConvexMesh","rawshape_castShape","rawshape_intersectsShape","rawshape_contactShape","rawshape_containsPoint","rawshape_projectPoint","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","RawShapeCastHitFinalization","__wbg_rawshapecasthit_free","rawshapecasthit_witness1","rawshapecasthit_normal1","rawshapecasthit_normal2","RawShapeContactFinalization","__wbg_rawshapecontact_free","RawVectorFinalization","__wbg_rawvector_free","zero","rawvector_zero","rawvector_new","rawvector_set_x","rawvector_set_z","xyz","rawvector_xyz","yxz","rawvector_yxz","zxy","rawvector_zxy","xzy","rawvector_xzy","yzx","rawvector_yzx","zyx","rawvector_zyx","__wbindgen_number_new","arg0","__wbindgen_boolean_get","__wbindgen_object_drop_ref","__wbindgen_number_get","arg1","__wbindgen_is_function","__wbg_rawraycolliderintersection_new","__wbg_rawcontactforceevent_new","__wbg_call_b3ca7c6051f9bec1","arg2","call","arguments","__wbg_call_8e7cb608789c2528","arg3","__wbg_call_938992c832f74314","arg4","__wbg_bind_4d857b598695205e","bind","__wbg_buffer_12d079cc21e14bdb","__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb","__wbg_new_63b92bc8671ed464","__wbg_set_a47bac70306a19a7","__wbg_length_c20a40f15020d68a","__wbg_newwithbyteoffsetandlength_4a659d079a1650e0","__wbg_set_bd975934d1b1fddb","__wbg_length_d25bbcbc3367f684","__wbg_newwithlength_1e8b839a06de01c5","__wbindgen_throw","__wbindgen_memory"],"sourceRoot":""}